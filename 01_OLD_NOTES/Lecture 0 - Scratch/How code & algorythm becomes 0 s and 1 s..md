![[Screenshot 2025-06-24 at 13.25.02.png]]
![[Screenshot 2025-06-24 at 13.25.11 1.png]]CS50 isn’t about memorising C syntax **or** staring at endless 0 s and 1 s.  
What matters is the *thinking* that sits **between** those two layers:

| Layer                      | What the Human Focuses On                                  | Eventually Becomes   |
| -------------------------- | ---------------------------------------------------------- | -------------------- |
| **Pseudocode / Algorithm** | Clear, language-like steps that solve a problem            | ↓ compiled           |
| **Source Code (e.g., C)**  | Formal expression of those steps in a programming language | ↓ assembled / linked |
| **Machine Code**           | Raw bit patterns understood by the CPU                     | —                    |

> “Today we’ll focus not on what this code looks like, **nor** the zeros and ones it becomes.” — David Malan  

---

### ⭐ Why This Matters  
* The *same* algorithm can be written in **any** language.  
* Mastering algorithms first lets you switch languages later with confidence.  
* Understanding the compile ➜ machine-code pipeline demystifies how software really runs.

---

### 🔄 Mental Workflow  
1. **Describe the idea in plain English / pseudocode.**  
2. **Translate to C (or Python, JavaScript, …).**  
3. **Trust the compiler** to handle the binary conversion.  
4. **Debug logic first**, then worry about syntax.

---

[[10_Courses/CS50x Harvard/00_Lectures/Lecture 0 - Scratch]]  
[[CS50x Harvard]]  
