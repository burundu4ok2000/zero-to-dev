---
title: 8
type: concept
tags: [cs50x, python, objects, basics]
---

# Python Objects — beginner notes

**Core ideas**
- [[Object]] = data + behavior bundled together. Everything in Python is an object (ints, strings, functions, modules).
- [[Class]] = a blueprint to create objects (instances).
- [[Instance]] = a concrete object created from a class.
- [[Attribute]] = data stored on an object (`obj.name`).
- [[Method]] = function defined inside a class that acts on the instance (`obj.action()`).
- [[Constructor]] = `__init__(self, ...)` runs right after a new object is created.
- [[self]] = the current instance (passed automatically on method calls).
- [[Dunder method]] (magic) = special hooks like `__str__`, `__len__`, `__iter__`, `__eq__` for Pythonic behavior.
- [[Encapsulation]]: use a leading underscore `_secret` for “internal” attributes (convention).

**Minimal class**
```python
class Student:
    def __init__(self, name, sid):
        self.name = name      # attribute
        self.sid = sid

    def label(self):          # method
        return f"{self.name} — {self.sid}"

jane = Student("Jane", 10)    # instance
print(jane.label())
```

**Common beginner patterns**
- [[Default argument]]s in constructors:
```python
class Point:
    def __init__(self, x=0, y=0):
        self.x, self.y = x, y
```
- [[Type annotation]]s (optional but helpful):
```python
class Box:
    def __init__(self, w: int, h: int) -> None:
        self.w: int = w
        self.h: int = h
```
- [[__str__]] and [[__repr__]] for readable printing / debugging:
```python
class Point:
    def __init__(self, x=0, y=0):
        self.x, self.y = x, y
    def __repr__(self):
        return f"Point(x={self.x}, y={self.y})"
```
- [[Property]] for computed/validated fields (Python’s getter/setter):
```python
class Celsius:
    def __init__(self, temp=0):
        self._c = temp

    @property
    def c(self):
        return self._c

    @c.setter
    def c(self, value):
        if value < -273.15:
            raise ValueError("Below absolute zero")
        self._c = value
```
- [[Class method]] and [[Static method]]:
```python
class User:
    domain = "example.com"

    def __init__(self, name):
        self.name = name

    @classmethod
    def with_domain(cls, name):
        return cls(f"{name}@{cls.domain}")

    @staticmethod
    def greet(who):
        return f"Hello, {who}!"
```
- [[Dataclass]] (quick boilerplate-free class):
```python
from dataclasses import dataclass

@dataclass
class Item:
    sku: str
    price: float = 0.0

i = Item("X1", 9.99)  # auto __init__/__repr__/__eq__
```
- [[Inheritance]] and [[super]]:
```python
class Animal:
    def speak(self):
        return "..."

class Dog(Animal):
    def speak(self):
        return "woof"

class GuideDog(Dog):
    def speak(self):
        return super().speak().upper()  # "WOOF"
```

**Idioms you’ll see a lot**
- Duck typing: “if it quacks like a duck…” — don’t check types, rely on methods/attributes.
- Composition over inheritance: prefer having objects to delegating behavior rather than deep hierarchies.
- Truthiness: objects can define `__bool__`/`__len__` to control `if obj:`.

**Quick checklist**
- Use CapWords for class names (`class MyThing:`).
- Keep methods small; return new objects for complex transforms.
- Start “private” attributes with `_` and document invariants.
- Implement `__repr__` for easier debugging.

**See also**
[[Class]], [[Instance]], [[Attribute]], [[Method]], [[Constructor]], [[Property]], [[Dataclass]], [[Inheritance]], [[Duck typing]]
