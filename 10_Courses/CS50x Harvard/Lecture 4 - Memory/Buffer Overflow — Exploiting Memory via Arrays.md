---
title: "Buffer Overflow — Exploiting Memory via Arrays"  
lang_tags: "#lang/c"
type_tags: "#type/lecture"
course_tags: "#course/cs50x/intoduction_to_CS"
lecture_tags: "#lecture/week_4_Memory"
tool_tags: ""
atom_idx: 23
status: "done"
difficulty: "medium"
date: "2025-08-27"
timecode: "1:50:00–1:52:00"
source: "https://cs50.harvard.edu/x/2025/weeks/4/"
review_next: "2025-09-27"
---

---

## Summary
A **buffer overflow** happens when you write **outside the bounds of an array**, typically in heap or stack memory. This can corrupt nearby memory — sometimes even **code execution**.

## Very simple

> Imagine you fill a glass of water (array), but you keep pouring.  
> Water spills over onto the table (memory next to the array).  
> If that "table" is important — like another variable or code — you’re in trouble.

## Key Points
- A **buffer** is a region of memory like an array or block from `malloc`.
- Writing past its limit = **buffer overflow**.
- Common in C when you forget to check size limits.
- Overwrites nearby variables, return addresses, or even control flow.
- Can lead to **crashes**, **data corruption**, or **security vulnerabilities**.

## Details

### Example (Stack-Based Buffer Overflow)

```c
void crash()
{
    char buffer[8];
    strcpy(buffer, "this is way too long for 8 bytes!");
}
```

```c
#include <stdio.h>
#include <string.h>

void crash() {
    char buffer[8];
    // Copying a string longer than buffer size causes overflow
    strcpy(buffer, "this is way too long for 8 bytes!");
    printf("Buffer contents: %s\n", buffer);
}

int main() {
    crash();
    printf("Function returned normally.\n");
    return 0;
}
```

### Possible terminal output:

```
Buffer contents: ThisIsWayTooLong
Function returned normally.
```

**But, in many cases, you might see something like:**

```
Buffer contents: ThisIsW
�\xFF\xFF\xFF\xFF\xFF
Function returned normally.
```

or even:

```
Buffer contents: ThisIsW�\x00\x00\x00
Function returned normally.
```

### Why it's dangerous:
- In real attacks, this could change the **return address** of the function.
- When the function ends, it "returns" to **malicious code** instead of where it should.
- This is how **shellcode injections** and **remote exploits** work.

## **Why It Matters**
- Buffer overflows are **one of the most dangerous bugs** in C/C++.
- They’ve been the basis of **real-world hacks** (e.g. early internet worms).
- They show why **memory safety** matters and why newer languages add built-in checks.

## Questions

- ❓How can tools like Valgrind or AddressSanitizer detect these bugs?
- ❓Why do languages like Python not have this problem?

## Related Concepts

- [[Stack Overflow vs Heap Overflow — Memory Crashes Explained]] – similar memory violation types.
- [[malloc and free]] – heap buffer overflows often happen in `malloc`ed memory.
- [[Pointers in C]] – allow writing to arbitrary memory locations.
- [[Memory Layout of a Program — Stack, Heap, Globals, Machine Code]] – explains where buffers live.
- [[Valgrind Basics]] – helps detect overflows.
- [[Dangling Pointers]] – another way to cause memory corruption.

## See also

- [Buffer Overflow — Wikipedia](https://en.wikipedia.org/wiki/Buffer_overflow)
- [Common Vulnerabilities — MITRE CWE-120](https://cwe.mitre.org/data/definitions/120.html)
- [AddressSanitizer — Clang Docs](https://clang.llvm.org/docs/AddressSanitizer.html)

## Terms

[[buffer]], [[overflow]], [[array]], [[memory corruption]], [[strcpy]], [[stack]], [[heap]], [[shellcode]], [[exploit]]
